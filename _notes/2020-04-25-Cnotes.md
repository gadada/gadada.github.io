---
title: "C语言学习汇总"
tags:
  - C/C++
categories:
  - Algorithm Basics
---
温故而知新

## hello world
C语言具有高效、灵活、功能丰富、表达力强和较高的可移植性的特点，C语言环境包括文本编辑器和C编译器，本篇在[vs2019]()平台运行

[C99](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80#C99)被ANSI于2000年3月采用。

2011年12月8日，ISO正式发布了新的C语言的新标准[C11](https://zh.wikipedia.org/wiki/C11)，之前被称为C1X，官方名称为`ISO/IEC 9899:2011`。新的标准提高了对C++的兼容性，是当前最新的C语言标准。在它之前的C语言标准为C99。这次修订新增了被主流C语言编译器(如GCC,Clang,Visual C++等)增加的内容，和引入了内存模型以更好的执行多线程。之前C99的一些被推迟的计划在C11中增加了，但是对C99仍保留向后兼容。

有时候，标准走在编译器的前面，而有时候，编译器又走在标准的后面……

### #include
头文件是C程序必不可少的内容，任何库函数的调用都需要提前包含头文件，处理头文件的过程为预编译过程

`#include<xx>`编译器会去系统配置的库环境变量或者用户配置的路径去搜索

`#include"xx"`编译器会先在项目的当前目录查找，找不到后才会去系统配置的库环境变量和用户配置的路径去搜索

常用头文件

| 头文件 | 功能 |	<center>描述</center> |
| :----: | :----: | :---- |
| [assert.h](https://www.runoob.com/cprogramming/c-standard-library-assert-h.html) | 诊断 |	仅包含assert宏。该宏可用来诊断程序状态，若检查失败，程序终止。|
| [ctype.h](https://www.runoob.com/cprogramming/c-standard-library-ctype-h.html) |	字符处理 | 包含判断字符类型及大小写转换的函数。|
| [errno.h](https://www.runoob.com/cprogramming/c-standard-library-errno-h.html) |	错误监测 | 在调用特定库函数后检测errno的值以判断调用过程中是否有错误发生。|
| [float.h](https://www.runoob.com/cprogramming/c-standard-library-float-h.html) |	浮点数特性 | 提供了描述浮点数特性的宏。|
| [limits.h](https://www.runoob.com/cprogramming/c-standard-library-limits-h.html) | 整型特性 |	提供了描述整数类型和字符类型特性的宏。|
| [locale.h](https://www.runoob.com/cprogramming/c-standard-library-locale-h.html) |	本地化 | 提供了一些支持程序国际化的函数。|
| [math.h](https://www.runoob.com/cprogramming/c-standard-library-math-h.html) | 数学计算 |	提供了大量用以数学计算的函数。|
| [setjmp.h](https://www.runoob.com/cprogramming/c-standard-library-setjmp-h.html) | 非本地跳转 |	提供了用于绕过正常的函数返回机制 |
| [signal.h](https://www.runoob.com/cprogramming/c-standard-library-signal-h.html) | 信号处理 |	提供了包括中断和运行时错误在内的异常情况处理函数。|
| [stdarg.h](https://www.runoob.com/cprogramming/c-standard-library-stdarg-h.html) | 不定参数 |	提供了支持函数处理不变个数的参数的工具。|
| [stddef.h](https://www.runoob.com/cprogramming/c-standard-library-stddef-h.html) | 常用定义 |	提供了常用的类型和宏。|
| [stdio.h](https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html) | 输入输出 | 提供了大量输入输出函数。|
| [stdlib.h](https://www.runoob.com/cprogramming/c-standard-library-stdlib-h.html) | 常用实用函数 |	提供了大量实用的函数。|
| [string.h](https://www.runoob.com/cprogramming/c-standard-library-string-h.html) | 字符串处理 |	提供了大量字符串处理函数。|
| [time.h](https://www.runoob.com/cprogramming/c-standard-library-time-h.html) | 日期和时间 |	提供了获取、操纵和处理日期的函数。|

### main函数
一个C程序有且仅有且不能没有一个main函数

`int main(void){}`明确表明没有任何参数，`int main(){}`可以有参数，也可以没有

### 注释
注释可以增加程序的可读性，程序主要是给人看的，注释会被编译器忽略
- `//单行注释`
- `/*中间全都是注释，无论单行多行*/`

### 语法
C语言中包含关键字、标识符、常量、字符串值和符号

分号：语句结束符，每个语句必须以分号结束。它表明一个逻辑实体的结束。

标识符：用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母`A-Z`或`a-z`或下划线`_`开始，后跟零个或多个字母、下划线和数字`0-9`。

关键字：C中的保留字，32个。这些保留字不能作为常量名、变量名或其他标识符名称。

| 关键字 | <center>说明</center> |
| :----: | :---- |
| auto | 声明自动变量 |
| break |	跳出当前循环 |
| case | 开关语句分支 |
| char | 声明字符型变量或函数返回值类型 |
| const	| 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环|
| default |	开关语句中的"其它"分支 |
| do | 循环语句的循环体 |
| double | 声明双精度浮点型变量或函数返回值类型 |
| else | 条件语句否定分支（与 if 连用）|
| enum | 声明枚举类型 |
| extern | 声明变量或函数是在其它文件或本文件的其他位置定义 |
| float |	声明浮点型变量或函数返回值类型 |
| for |	一种循环语句 |
| goto | 无条件跳转语句 |
| if | 条件语句 |
| int |	声明整型变量或函数 |
| long | 声明长整型变量或函数返回值类型 |
| register | 声明寄存器变量 |
| return |	子程序返回语句（可以带参数，也可不带参数） |
| short |	声明短整型变量或函数 |
| signed | 声明有符号类型变量或函数 |
| sizeof | 计算数据类型或变量长度（即所占字节数） |
| static | 声明静态变量 |
| struct | 声明结构体类型 |
| switch | 用于开关语句 |
| typedef |	用以给数据类型取别名 |
| unsigned | 声明无符号类型变量或函数 |
| union |	声明共用体类型 |
| void | 声明函数无返回值或无参数，声明无类型指针 |
| volatile | 说明变量在程序执行中可被隐含地改变 |
| while | 循环语句的循环条件 |

C99 新增关键字

`_Bool`、`_Complex`、`_Imaginary`、`inline`、`restrict`

C11 新增关键字

`_Alignas`、`_Alignof`、`_Atomic`、`_Generic`、`_Noreturn`、`_Static_assert`、`_Thread_local`

空格：用来分隔关键字和变量名，帮助编译器区分；除此以外，空白符、制表符、换行符均会被编译器忽略

### 数据类型（以x64机器为例）
整型

| 类型 | 存储大小 |	值范围 |
| :----: | :----: | ---- |
| char | 1 字节	| -128 到 127 或 0 到 255 |
| unsigned char | 1 字节 | 0 到 255 |
| signed char |	1 字节 | -128 到 127 |
| int |	4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int | 4 字节 | 0 到 65,535 或 0 到 4,294,967,295 |
| short |	2 字节 | -32,768 到 32,767 |
| unsigned short | 2 字节 |	0 到 65,535 |
| long | 4 字节 |	-2,147,483,648 到 2,147,483,647 |
| unsigned long |	4 字节 | 0 到 4,294,967,295 |

浮点类型

| 类型 | 存储大小 |	值范围 | 精度 |
| :----: | :----: | ---- | ---- |
| float |	4 字节 | 1.2E-38 到 3.4E+38 |	6 位小数|
| double | 8 字节 | 2.3E-308 到 1.7E+308 | 15 位小数 |
| long double	| 16 字节	| 3.4E-4932 到 1.1E+4932 | 19 位小数 |

### 变量
C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。

几种基本的变量类型

| 类型 | <center>描述</center> |
| :----: | ---- |
| char | 通常是一个字节（8位）。这是一个整数类型。|
| int |	对机器而言，整数的最自然的大小。|
| float | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。|
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数。|
| void | 表示类型的缺失。|

除此之外还有枚举、指针、数组、结构、共用体等等，他们都是需要建立存储空间的，而使用`extern`关键字声明变量名而不定义它，不需要建立存储空间

C 中的左值（Lvalues）和右值（Rvalues）
- 左值（lvalue）：指向内存位置的表达式被称为左值表达式。左值可以出现在赋值号的左边或右边。
- 右值（rvalue）：指存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

### 常量
常量是固定值，在程序执行期间不会改变，可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量

- 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

```c
212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
```

- 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

```c
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
```

- 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

- 字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

- 定义常量
  - #define 预处理器：`#define identifier value`
  - const 关键字：`const type variable = value;`

### 存储类
存储类：`auto`,`register`,`static`,`extern`

- auto

auto 存储类是所有局部变量默认的存储类。

```c
//定义两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量
int mount;
auto int month;
```

- register

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

```c
{
  register int  miles;
}
```

- static

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

```c
#include <stdio.h>

/* 函数声明 */
void func(void);
static int count=10;        /* 全局变量 - static 是默认的 */
int main(){
  while (count--) {
      func();
  }
  return 0;
}
void func(void){
/* 'thing' 是 'func' 的局部变量 - 只初始化一次
  每次调用函数 'func' 'thing' 值不会被重置。*/
  static int thing=5;
  thing++;
  printf(" thing 为 %d ， count 为 %d\n", thing, count);
}
```

- extern

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

```c
//第一个文件：main.c
#include <stdio.h>

int count ;
extern void write_extern();
int main()
{
   count = 5;
   write_extern();
}
```
```c
//第二个文件：support.c
#include <stdio.h>

extern int count;
void write_extern(void)
{
   printf("count is %d\n", count);
}
```

### 运算符
C 语言内置了丰富的运算符，并提供了以下类型的运算符：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、杂项运算符

- 算术运算符

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| + |	把两个操作数相加 | A + B 将得到 30 |
| - |	从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *	| 把两个操作数相乘 | A * B 将得到 200 |
| / |	分子除以分母 | B / A 将得到 2 |
| % |	取模运算符，整除后的余数 | B % A 将得到 0 |
| ++ | 自增运算符，整数值增加 1 |	A++ 将得到 11 |
| -- | 自减运算符，整数值减少 1 |	A-- 将得到 9 |

- 关系运算符

假设变量 A 的值为 10，变量 B 的值为 20

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| == | 检查两个操作数的值是否相等，如果相等则条件为真。|	(A == B) 为假。|
| != |	检查两个操作数的值是否相等，如果不相等则条件为真。|	(A != B) 为真。|
| > |	检查左操作数的值是否大于右操作数的值，如果是则条件为真。|	(A > B) 为假。|
| < |	检查左操作数的值是否小于右操作数的值，如果是则条件为真。|	(A < B) 为真。|
| >= |	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。|	(A >= B) 为假。|
| <= |	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。|	(A <= B) 为真。|

- 逻辑运算符

假设变量 A 的值为 1，变量 B 的值为 0

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| `&&` |	称为逻辑与运算符。如果两个操作数都非零，则条件为真。|	`(A && B)` 为假。|
| `||` |	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。|	`(A || B)` 为真。|
| `!` |	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。|	`!(A && B)` 为真。|

- 位运算符

假设变量 A 的值为 60，变量 B 的值为 13，

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| `&` | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;``0&1=0;``1&0=0;``1&1=1;` | (A & B) 将得到 12，即为 0000 1100 |
| `|` | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;``0|1=1;``1|0=1;``1|1=1;` |	(A | B) 将得到 61，即为 0011 1101 |
| `^` | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;``0^1=1;``1^0=1;``1^1=0;` |	(A ^ B) 将得到 49，即为 0011 0001 |
| `~` | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=0;``~0=1;` |	(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。|
| `<<` |	二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。|	A << 2 将得到 240，即为 1111 0000 |
| `>>` | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。|	A >> 2 将得到 15，即为 0000 1111 |

- 赋值运算符

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| `=` |	简单的赋值运算符，把右边操作数的值赋给左边操作数 |	`C = A + B` 将把 `A + B` 的值赋给 C |
| `+=` | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 |	`C += A` 相当于 `C = C + A` |
| `-=` | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 |	`C -= A` 相当于 `C = C - A` |
| `*=` | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 |	`C *= A` 相当于 `C = C * A` |
| `/=` | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | `C /= A` 相当于 `C = C / A` |
| `%=` | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 |	`C %= A` 相当于 `C = C % A` |
| `<<=` |	左移且赋值运算符 |	`C <<= 2` 等同于 `C = C << 2` |
| `>>=` |	右移且赋值运算符 |	`C >>= 2` 等同于 `C = C >> 2` |
| `&=` |	按位与且赋值运算符 |	`C &= 2` 等同于 `C = C & 2` |
| `^=` |	按位异或且赋值运算符 |	`C ^= 2` 等同于 `C = C ^ 2` |
| `|=` 	| 按位或且赋值运算符 |	`C |= 2` 等同于 `C = C | 2` |

- 杂项运算符

| 运算符 | <center>描述</center> | <center>实例</center> |
| :----: | ---- | ---- |
| `sizeof()` |	返回变量的大小。|	`sizeof(a)` 将返回 4，其中 a 是整数。|
| `&` |	返回变量的地址。|	`&a;` 将给出变量的实际地址。|
| `*` |	指向一个变量。|	`*a;` 将指向一个变量。|
| `? :` |	条件表达式 |	如果条件为真 ? 则值为 X : 否则值为 Y |

### 判断
C 语言把任何非零和非空的值假定为 true，把零或 `NULL` 假定为 false。

- 判断语句

| 语句 | <center>描述</center> |
| :----: | ---- |
| if 语句 |	一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。|
| if...else 语句 |	一个 if 语句 后跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。|
| 嵌套 if 语句 |	在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。|
| switch 语句 |	一个 switch 语句测试一个变量等于多个值时的情况。|
| 嵌套 switch 语句 | 在一个 switch 语句内使用另一个 switch 语句。|

- 三元运算符

```c
Exp1 ? Exp2 : Exp3;
```

### 循环
循环语句允许我们多次执行一个语句或语句组

| 循环类型 | <center>描述</center> |
| :----: | ---- |
| while 循环 |	当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。|
| for 循环 |	多次执行一个语句序列，简化管理循环变量的代码。|
| do...while 循环 |	除了它是在循环主体结尾测试条件外，其他与 while 语句类似。|
| 嵌套循环 |	可以在 while、for 或 do..while 循环内使用一个或多个循环。|

| 循环控制语句 | <center>描述</center> |
| :----: | ---- |
| break 语句 |	终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。|
| continue 语句 |	告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。|
| goto 语句 |	将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。|

### 函数
函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。

函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。

定义函数
- 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。
- 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- 参数：参数就像是占位符。当函数被调用时，用户向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- 函数主体：函数主体包含一组定义函数执行任务的语句。

```c
return_type function_name( parameter list )
{
   body of the function
}
```

- 函数声明

函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

```c
return_type function_name( parameter list );
```

- 调用函数

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。

- 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

- 传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。
- 引用调用：通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

### 作用域规则
作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：
- 在函数或块内部的局部变量
- 在所有函数外部的全局变量
- 在形式参数的函数参数定义中

局部变量：在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。

```c
#include <stdio.h>

int main ()
{
  /* 局部变量声明 */
  int a, b;
  int c;

  /* 实际初始化 */
  a = 10;
  b = 20;
  c = a + b;
  printf ("value of a = %d, b = %d and c = %d\n", a, b, c);

  return 0;
}
```

全局变量：定义在函数外部，全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。

```c
#include <stdio.h>

/* 全局变量声明 */
int g;

int main ()
{
  /* 局部变量声明 */
  int a, b;

  /* 实际初始化 */
  a = 10;
  b = 20;
  g = a + b;
  printf ("value of a = %d, b = %d and g = %d\n", a, b, g);

  return 0;
}
```
注：局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。

形式参数：函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。

```c
#include <stdio.h>

/* 全局变量声明 */
int a = 20;

int main ()
{
  /* 在主函数中的局部变量声明 */
  int a = 10;
  int b = 20;
  int c = 0;
  int sum(int, int);

  printf ("value of a in main() = %d\n",  a);
  c = sum( a, b);
  printf ("value of c in main() = %d\n",  c);

  return 0;
}

/* 添加两个整数的函数 */
int sum(int a, int b)
{
    printf ("value of a in sum() = %d\n",  a);
    printf ("value of b in sum() = %d\n",  b);

    return a + b;
}
```

- 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化

| 数据类型 |	初始化默认值 |
| :----: | :----: |
| int |	0 |
| char |	'\0' |
| float |	0 |
| double |	0 |
| pointer |	NULL |

### 数组
C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

![picture]({{site.url}}{{site.baseurl}}/images/posts/array.jpg)

声明数组

```c
//一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。
type arrayName [arraySize];
```

初始化数组
- 逐个初始化数组

  ```c
  //大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。
  double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
  //如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。与前一个数组完全相同
  double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
  ```

访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。

```c
double salary = balance[9];
```

C 数组的一些细节

| 概念 |	<center>描述</center> |
| :----: | ---- |
| 多维数组	| C 支持多维数组。多维数组最简单的形式是二维数组。|
| 传递数组给函数 |	可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。|
| 从函数返回数组 |	C 允许从函数返回数组。|
| 指向数组的指针 | 可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。|

以二维数组为例,`int x[3][4];`

![picture]({{site.url}}{{site.baseurl}}/images/posts/two_arrays.jpg)

初始化二维数组

```c
int a[3][4] = {
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
//内部嵌套的括号是可选的，下面的初始化与上面是等同的
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

//简单粗暴
int a[3][4] = { 0 };
//更高级的用法,效果同上
#include<string>
...
memeset(a, 0, sizeof(a));

//动态二维数组
#include<stdlib.h>
...
int ** a;
//r行
a=(int** )malloc(r * sizeof(int* ));
//c列
for(int i = 0; i < r; i++){
    a[i]=(int*)malloc(c*sizeof(int));
}
```

[二维数组传参](https://gadada.github.io/notes/2020-04-07-TwoArray/)

### enum(枚举)
枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。

```c
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7

//第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。
//在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推
enum DAY
{
  MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

枚举变量的定义

```c
//先定义枚举类型，再定义枚举变量
enum DAY
{
  MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;

//定义枚举类型的同时定义枚举变量
enum DAY
{
  MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;

//省略枚举名称，直接定义枚举变量
enum
{
  MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;

...
int main()
{
  // 遍历枚举元素
  for (day = MON; day <= SUN; day++) {
    printf("枚举元素：%d \n", day);
  }
  return 0;
}
```
枚举在 switch 中的使用

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{

    enum color { red=1, green, blue };
    enum color favorite_color;

    /* ask user to choose color */
    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf("%d", &favorite_color);

    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }

    return 0;
}

//反过来也可以将整数转换为枚举
#include <stdio.h>
#include <stdlib.h>

int main()
{
  enum day {
    saturday,
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
  } workday;

  int a = 1;
  enum day weekend;
  weekend = (enum day) a;  //类型转换
  //weekend = a; //错误
  printf("weekend:%d",weekend);
  return 0;
}
```

### 指针
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。

声明一个指针

```c
//type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。
type *var-name;
//eg
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;     /* 一个字符型的指针 */
```

定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。

```c
#include <stdio.h>

int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int* ip;        /* 指针变量的声明 */

   ip = &var;  /* 在指针变量中存储 var 的地址 */
   printf("Address of var variable: %p\n", &var  );
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );

   return 0;
}
```

NULL 指针

赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量。

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。为指针变量赋一个 NULL 值是一个良好的编程习惯。

```c
if(ptr)     /* 如果 p 非空 */
if(!ptr)    /* 如果 p 为空 */
```

关于指针的一些用法

| 概念 |	<center>描述</center> |
| :----: | ---- |
| 指针的算术运算 |	可以对指针进行四种算术运算：++、--、+、- |
| 指针数组 |	可以定义用来存储指针的数组。|
| 指向指针的指针 |	C 允许指向指针的指针。|
| 传递指针给函数 |	通过引用或地址传递参数，使传递的参数在调用函数中被改变。|
| 从函数返回指针 |	C 允许函数返回指针到局部变量、静态变量和动态内存分配。|

指针的运算

假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```c
ptr++;
```
在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。
- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

指针的比较

指针可以用关系运算符进行比较，如 ==、< 和 >。

```c
#include <stdio.h>

const int MAX = 3;

int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;

   /* 指针中第一个元素的地址 */
   ptr = var;
   i = 0;
   while ( ptr <= &var[MAX - 1] )
   {
      //变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]
      printf("Address of var[%d] = %p\n", i, ptr );
      printf("Value of var[%d] = %d\n", i, *ptr );

      /* 指向上一个位置 */
      ptr++;
      i++;
   }
   return 0;
}
```

指针数组

```c
//其实就是一组指针
int *ptr[MAX];
```
把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。

指向指针的指针

```c
int **var;
```
![picture]({{site.url}}{{site.baseurl}}/images/posts/pointer_to_pointer.jpg)

```c
#include <stdio.h>

int main ()
{
   int  var;
   int  *ptr;
   int  **pptr;

   var = 3000;

   /* 获取 var 的地址 */
   ptr = &var;

   /* 使用运算符 & 获取 ptr 的地址 */
   pptr = &ptr;

   /* 使用 pptr 获取值 */
   printf("Value of var = %d\n", var );
   printf("Value available at *ptr = %d\n", *ptr );
   printf("Value available at **pptr = %d\n", **pptr);
   //上面三个输出的值时一样的

   return 0;
}
```

传递指针给函数

```c
#include <stdio.h>

/* 函数声明 */
double getAverage(int *arr, int size);

int main ()
{
   /* 带有 5 个元素的整型数组  */
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;

   /* 传递一个指向数组的指针作为参数，可以看出，指针和数组其实是通用的 */
   avg = getAverage( balance, 5) ;

   /* 输出返回值  */
   printf("Average value is: %f\n", avg);

   return 0;
}

double getAverage(int *arr, int size)
{
  int i, sum = 0;
  double avg;

  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
  }

  avg = (double)sum / size;

  return avg;
}
```

从函数返回一个指针则只需改变函数名前面的类型即可

```c
int * myFunction()
{
//function body
}
```

函数指针

函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

函数指针可以像一般函数一样，用于调用函数、传递参数。函数指针变量的声明：

```c
typedef int (*fun_ptr)(int,int);// 声明一个指向同样参数、返回值的函数指针类型
```
举个栗子

```c
#include <stdio.h>

int max(int x, int y){
    return x > y ? x : y;
}
int main(void)
{
  /* p 是函数指针 */
  int (* p)(int, int) = & max; // &可以省略
  int a, b, c, d;

  printf("请输入三个数字:");
  scanf("%d %d %d", & a, & b, & c);

  /* 与直接调用函数等价，d = max(max(a, b), c) */
  d = p(p(a, b), c);

  printf("最大的数字是: %d\n", d);

  return 0;
}
```

回调函数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。具体见代码

```c
//populate_array函数定义了三个参数，第三个参数是函数的指针，该函数用来设置数组的值。
//回调函数getNextRandomValue返回一个随机值，它作为函数指针传递给populate_array函数
//populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。
#include <stdlib.h>
#include <stdio.h>

// 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
  for (size_t i=0; i<arraySize; i++)
    array[i] = getNextValue();
}

// 获取随机值
int getNextRandomValue(void)
{
  return rand();
}

int main(void)
{
  int myarray[10];
  populate_array(myarray, 10, getNextRandomValue);
  for(int i = 0; i < 10; i++) {
    printf("%d ", myarray[i]);
  }
  printf("\n");
  return 0;
}
```

### 字符串
字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。

![picture]({{site.url}}{{site.baseurl}}/images/posts/string.jpg)

字符串的初始化
```c
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
//C 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾。
char greeting[] = "Hello";
```

C 中有大量操作字符串的函数：

| 函数 | 目的 |
| :----: | ---- |
| strcpy(s1, s2); | 复制字符串 s2 到字符串 s1。|
|	strcat(s1, s2); | 连接字符串 s2 到字符串 s1 的末尾。|
|	strlen(s1); | 返回字符串 s1 的长度。|
|	strcmp(s1, s2); | `s1 == s2`，则返回 0；`s1 < s2`则返回小于0；`s1 > s2`则返回大于0。|
|	strchr(s1, ch); | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
| strstr(s1, s2); | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

```c
#include <stdio.h>
#include <string.h>

int main ()
{
   char str1[12] = "Hello";
   char str2[12] = "World";
   char str3[12];
   int  len ;

   /* 复制 str1 到 str3 */
   strcpy(str3, str1);
   printf("strcpy( str3, str1) :  %s\n", str3 );

   /* 连接 str2 到 str1 末尾 */
   strcat( str1, str2);
   printf("strcat( str1, str2):   %s\n", str1 );

   /* str1 的总长度 */
   len = strlen(str1);
   printf("strlen(str1) :  %d\n", len );

   return 0;
}
```

### 结构体
结构是 C 编程中另一种用户自定义的可用的数据类型，允许存储不同类型的数据项。

```c
//使用 struct 语句定义结构
struct tag {
    member-list
    member-list
    member-list
    ...
} variable-list ;
```
tag 是结构体标签。

member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。

variable-list 结构变量，定义在结构的末尾，最后一个分号之前，可以指定一个或多个结构变量。

```c
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct {
  int a;
  char b;
  double c;
} s1;

//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE {
  int a;
  char b;
  double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;

//也可以用typedef创建新类型
typedef struct {
  int a;
  char b;
  double c;
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;

//此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;
};

//此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};

//如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明
struct B;    //对结构体B进行不完整声明
//结构体A中包含指向结构体B的指针
struct A
{
    struct B *partner;
    //other members;
};
//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
    struct A *partner;
    //other members;
};
```

结构体变量的初始化

```c
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};
```
访问结构成员

```c
#include <stdio.h>
#include <string.h>

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */

   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali");
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;

   /* 输出 Book1 信息 */
   printf( "Book 1 title : %s\n", Book1.title);
   printf( "Book 1 author : %s\n", Book1.author);
   printf( "Book 1 subject : %s\n", Book1.subject);
   printf( "Book 1 book_id : %d\n", Book1.book_id);

   /* 输出 Book2 信息 */
   printf( "Book 2 title : %s\n", Book2.title);
   printf( "Book 2 author : %s\n", Book2.author);
   printf( "Book 2 subject : %s\n", Book2.subject);
   printf( "Book 2 book_id : %d\n", Book2.book_id);

   return 0;
}
```
结构作为函数参数

```c
#include <stdio.h>
#include <string.h>

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */

   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali");
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;

   /* 输出 Book1 信息 */
   printBook( Book1 );

   /* 输出 Book2 信息 */
   printBook( Book2 );

   return 0;
}
void printBook( struct Books book )
{
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}
```
指向结构的指针

```c
//定义结构体指针
struct Books *struct_pointer;
//结构变量的地址
struct_pointer = &Book1;
//使用指向该结构的指针访问结构的成员
struct_pointer->title;
```

```c
#include <stdio.h>
#include <string.h>

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */

   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali");
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;

   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &Book1 );

   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &Book2 );

   return 0;
}
void printBook( struct Books *book )
{
   printf( "Book title : %s\n", book->title);
   printf( "Book author : %s\n", book->author);
   printf( "Book subject : %s\n", book->subject);
   printf( "Book book_id : %d\n", book->book_id);
}
```

位域

有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

```c
//位域定义
struct 位域结构名
{
 位域列表

};
/* 其中位域列表的形式为：
类型说明符 位域名: 位域长度 */
struct bs{
    int a:8;
    int b:2;
    int c:6;
}data;

/*位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。
一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，
则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。 */
struct bs{
  unsigned a:4;
  unsigned  :4;    /* 空域 */
  unsigned b:4;    /* 从下一单元开始存放 */
  unsigned c:4
}
struct k{
  int a:1;
  int  :2;    /* 该 2 位不能使用 */
  int b:3;
  int c:2;
};
```
位域的使用

```c
main(){
  struct bs{
      unsigned a:1;
      unsigned b:3;
      unsigned c:4;
  } bit,*pbit;
  bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
  bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
  bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
  printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
  pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
  pbit->a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
  pbit->b&=3;    /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，
  位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为3） */
  pbit->c|=1;   /* 使用了复合位运算符"|="，即：pbit->c=pbit->c|1，其结果为15 */
  printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);  /* 输出了这三个域的值 */
}
```

### 共用体
共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

```c
/* union tag 是可选的，每个member definition是标准的变量定义，比如int i; float f;
在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。*/
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];

union Data
{
   int i;
   float f;
   char  str[20];
} data;
/*Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。
一个变量（相同的内存位置）可以存储多个多种类型的数据。*/
```
共用体占用的内存应足够存储共用体中最大的成员。

```c
#include <stdio.h>
#include <string.h>

union Data
{
  int i;
  float f;
  char  str[20];
};

int main( )
{
  union Data data;

  printf( "%d\n", sizeof(data)); // 20

  return 0;
}
```
访问共用体成员

```c
#include <stdio.h>
#include <string.h>

union Data
{
   int i;
   float f;
   char  str[20];
};

int main( )
{
   union Data data;

   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");

   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);

   return 0;
}

data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming
```
共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。

### typedef
C 语言提供了 typedef 关键字，可以使用它来为类型取一个新的名字。

```c
typedef unsigned char BYTE;
//按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写
```
typedef vs #define
- `typedef`仅限于为类型定义符号名称，`#define`不仅可以为类型定义别名，也能为数值定义别名
- `typedef`是由编译器执行解释的，`#define`语句是由预编译器进行处理的。

### 输入和输出
当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。

当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。

| 标准文件 | 文件指针 |	设备 |
| ---- | ---- | ---- |
| 标准输入 | stdin | 键盘 |
| 标准输出 | stdout | 屏幕 |
| 标准错误 | stderr	 | 屏幕 |


C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。
int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。

int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。

format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。

```c
#include <stdio.h>
int main( ) {

   char str[100];
   int i;

   printf( "Enter a value :");
   scanf("%s %d", str, &i);

   printf( "\nYou entered: %s %d ", str, i);
   printf("\n");
   return 0;
}
```
在读取字符串时，只要遇到一个空格，[scanf()](https://gadada.github.io/notes/2020-04-06-String/) 就会停止读取

- getchar() & putchar() 函数

int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

- gets() & puts() 函数

char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。

int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。

### 文件读写
C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。

打开文件

```c
FILE *fopen( const char * filename, const char * mode );
```

| 模式 |	描述 |
|:----:| ---- |
| r |	打开一个已有的文本文件，允许读取文件。|
| w	 |打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。|
| a |	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。|
| r+ |	打开一个文本文件，允许读写文件。|
| w+ |	打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。|
| a+ |	打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

`"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"`

关闭文件

```c
int fclose( FILE *fp );
```
如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。

写入文件

把字符(串)写入到流中的函数

```c
int fputc( int c, FILE *fp );
/*函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。
如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。*/

int fputs( const char *s, FILE *fp );
/*函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。
如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。*/
```

在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。

```c
#include <stdio.h>

int main()
{
   FILE *fp = NULL;

   fp = fopen("/tmp/test.txt", "w+");
   fprintf(fp, "This is testing for fprintf...\n");
   fputs("This is testing for fputs...\n", fp);
   fclose(fp);
}
```

读取文件

从文件读取单个字符的函数

```c
int fgetc( FILE * fp );
/*fgetc() 函数从 fp 所指向的输入文件中读取一个字符。
返回值是读取的字符，如果发生错误则返回 EOF。*/

char *fgets( char *buf, int n, FILE *fp );
/*函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。
它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。
如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，
则只会返回读取到的字符，包括换行符。*/
```

fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。

```c
#include <stdio.h>

int main()
{
   FILE *fp = NULL;
   char buff[255];

   fp = fopen("/tmp/test.txt", "r");
   fscanf(fp, "%s", buff);
   printf("1: %s\n", buff );

   fgets(buff, 255, (FILE*)fp);
   printf("2: %s\n", buff );

   fgets(buff, 255, (FILE*)fp);
   printf("3: %s\n", buff );
   fclose(fp);

}
```

二进制 I/O 函数的输入与输出

```c
size_t fread(void *ptr, size_t size_of_elements,
          size_t number_of_elements, FILE *a_file);

size_t fwrite(const void *ptr, size_t size_of_elements,
          size_t number_of_elements, FILE *a_file);
```

### 预处理器
C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。C 预处理器（C Preprocessor）简写 CPP。

所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。

| 指令 |	描述 |
| ---- | ---- |
| #define |	定义宏 |
| #include |	包含一个源代码文件 |
| #undef |	取消已定义的宏 |
| #ifdef |	如果宏已经定义，则返回真 |
| #ifndef |	如果宏没有定义，则返回真 |
| #if |	如果给定条件为真，则编译下面代码 |
| #else	| #if 的替代方案 |
| #elif |	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |
| #endif |	结束一个 #if……#else 条件编译块 |
| #error |	当遇到标准错误时，输出错误消息 |
| #pragma |	使用标准化方法，向编译器发布特殊的命令到编译器中 |

预处理器实例

```c
#define MAX_ARRAY_LENGTH 20
/* 这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。增强可读性。*/

#include <stdio.h>
#include "myheader.h"
/* 这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。
下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。*/

#undef  FILE_SIZE
#define FILE_SIZE 42
/* 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。*/

#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
/* 这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。*/

#ifdef DEBUG
   /* Your debugging statements here */
#endif
/* 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。
在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。
它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。*/
```

预定义宏

ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。

| 宏	| 描述 |
|`__DATE__`|	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。|
|`__TIME__`|	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。|
|`__FILE__`|	这会包含当前文件名，一个字符串常量。|
|`__LINE__`|	这会包含当前行号，一个十进制常量。|
|`__STDC__`|	当编译器以 ANSI 标准编译时，则定义为 1。|


预处理器运算符

```c
//一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

//在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。
#include <stdio.h>

#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

int main(void)
{
   message_for(Carole, Debra);
   return 0;
}
//Carole and Debra: We love you!

//宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。
#include <stdio.h>

#define tokenpaster(n) printf ("token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;

   tokenpaster(34);
   return 0;
}
//token34 = 40

/*预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。
如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。*/
#include <stdio.h>

#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

int main(void)
{
   printf("Here is the message: %s\n", MESSAGE);
   return 0;
}
//Here is the message: You wish!
```

参数化的宏

在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。

```c
#define square(x) ((x) * (x))
```