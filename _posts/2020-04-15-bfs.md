---
title: "算法基础part5"
tags:
  - C/C++
  - bfs
categories:
  - Algorithm Basics
---
DFS and BFS

## 图的遍历
- 深度优先搜索算法（Depth-First-Search）

  DFS是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。这种算法不会根据图的结构等信息调整执行策略。

- 广度优先搜索算法（Breadth-First Search）

  BFS是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。

该part主要对比两种遍历算法，学习其适用情况

### Q1
[红与黑](http://cxsjsxmooc.openjudge.cn/2020t2springall/018/)

有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。
- 输入：
  包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下
  - ‘.’：黑色的瓷砖；
  - ‘#’：白色的瓷砖；
  - ‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。

  当在一行中读入的是两个零时，表示输入结束。
- 输出：
  对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。
- 样例输入
  ```markdown
  6 9
  ....#.
  .....#
  ......
  ......
  ......
  ......
  ......
  #@...#
  .#..#.
  0 0
  ```
- 样例输出
  ```markdown
  45
  ```

`dfs`使用栈来辅助

```c
#include<stdio.h>
#include<string.h>

struct node {
	int i, j;
}s[400];
int W, H, bi, bj, ti, tj;
int visit[20][20];
char a[21][21];
int cnt;
int dx[4] = { 0, 1, 0, -1 }; //上下左右方向
int dy[4] = { 1, 0, -1, 0 };
int Isway(int i, int j)
{
	if (i < 0 || i >= H || j < 0 || j >= W)
		return 0;
	if (visit[i][j]) return 0;
	if (a[i][j] == '.') return 1;
	return 0;
}
void dfs()
{
	int top = 0;
	s[top].i = bi;
	s[top].j = bj;
	visit[s[top].i][s[top].j] = 1;
	top++;
	cnt++;
	while (top > 0) {
		int tag = 0;
		for (int i = 0; i < 4; ++i) {
			ti = s[top - 1].i + dx[i];
			tj = s[top - 1].j + dy[i];
			if (Isway(ti, tj)) {
				tag = 1;
				s[top].i = ti;
				s[top].j = tj;
				visit[s[top].i][s[top].j] = 1;
				top++;
				cnt++;
				break;
			}
		}
		if (tag == 0)top--;
	}
}
int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	while (~scanf("%d %d", &W, &H)) {
		memset(visit, 0, sizeof(visit));
		cnt = 0;
		if (W == 0 && H == 0) break;
		int i, j, k;
		for (i = 0; i < H; ++i) {
			getchar();
			for (j = 0; j < W; ++j) {
				scanf("%c", &a[i][j]);
				if (a[i][j] == '@')
					bi = i, bj = j;
			}
		}
		dfs();
		printf("%d\n", cnt);
	}

	return 0;
}
```
`bfs`用队列来辅助

```c
#include<stdio.h>
#include<string.h>

struct node {
	int i, j;
}q[400];
int W, H, bi, bj, ti, tj;
int visit[20][20];
char a[21][21];
int cnt;
int dx[4] = { 0, 1, 0, -1 }; //上下左右方向
int dy[4] = { 1, 0, -1, 0 };
int Isway(int i, int j)
{
	if (i < 0 || i >= H || j < 0 || j >= W)
		return 0;
	if (visit[i][j]) return 0;
	if (a[i][j] == '.') return 1;
	return 0;
}
void bfs()
{
	int first = 0, rear = 0;
	q[rear].i = bi;
	q[rear].j = bj;
	visit[q[rear].i][q[rear].j] = 1;
	rear++;
	cnt++;
	while (first < rear) {
		for (int i = 0; i < 4; ++i) {
			ti = q[first].i + dx[i];
			tj = q[first].j + dy[i];
			if (Isway(ti, tj)) {
				q[rear].i = ti;
				q[rear].j = tj;
				visit[q[rear].i][q[rear].j] = 1;
				rear++;
				cnt++;
			}
		}
		first++;
	}
}
int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	while (~scanf("%d %d", &W, &H)) {
		memset(visit, 0, sizeof(visit));
		cnt = 0;
		if (W == 0 && H == 0) break;
		int i, j, k;
		for (i = 0; i < H; ++i) {
			getchar();
			for (j = 0; j < W; ++j) {
				scanf("%c", &a[i][j]);
				if (a[i][j] == '@')
					bi = i, bj = j;
			}
		}
		bfs();
		printf("%d\n", cnt);
	}
	return 0;
}
```
毕竟考研预习了那么久，思路还是很清晰的

### Q2
[A Knight's Journey](http://cxsjsxmooc.openjudge.cn/2020t2springall/019/)

**Background**

The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey
around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board, but it is still rectangular. Can you help this adventurous knight to make travel plans?

**Problem**

Find a path such that the knight visits every square once. The knight can start and end on any square of the board.
- 输入

  The input begins with a positive integer n in the first line. The following lines contain n test cases. Each test case consists of a single line with two positive integers p and q, such that 1 <= p * q <= 26. This represents a p * q chessboard, where p describes how many different square numbers 1, . . . , p exist, q describes how many different square letters exist. These are the first q letters of the Latin alphabet: A, . . .
- 输出

  The output for every scenario begins with a line containing "Scenario #i:", where i is the number of the scenario starting at 1. Then print a single line containing the lexicographically first path that visits all squares of the chessboard with knight moves followed by an empty line. The path should be given on a single line by concatenating the names of the visited squares. Each square name consists of a capital letter followed by a number.

  If no such path exist, you should output impossible on a single line.
- 样例输入
  ```markdown
  3
  1 1
  2 3
  4 3
  ```
- 样例输出
  ```markdown
  Scenario #1:
  A1

  Scenario #2:
  impossible

  Scenario #3:
  A1B3C1A2B4C2A3B1C3A4B2C4
  ```

该题要从某一点出发找能够遍历所有点的通路，因此要用dfs，在dfs递归过程中设置一个数组`way`记录路径

此外，马走日，行用阿拉伯数字`1,2...`，列用`A,B...`，打印时要遵循字典序

```c
#include<stdio.h>
#include<string.h>

int p, q, t;
int way[26][2] = { 0 }, visit[26][26];
int dx[8] = { -2,-2,-1,-1,1,1,2,2 };//负数排在前
int dy[8] = { -1,1,-2,2,-2,2,-1,1 };
int dfs(int cnt, int x, int y)
{
	if (cnt == t)return 1;

	for (int i = 0; i < 8; i++) {
		int tx = x + dx[i], ty = y + dy[i];
		if (tx >= 0 && tx < q && ty >= 0 && ty < p && !visit[tx][ty]) {
			visit[tx][ty] = 1;
			if (dfs(cnt + 1, tx, ty)) {
				way[cnt][0] = tx, way[cnt][1] = ty;
				return 1;
			}
			visit[tx][ty] = 0;
		}
	}
	return 0;
}
int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		memset(visit, 0, sizeof(visit));
		visit[0][0] = 1;
		scanf("%d%d", &p, &q);
		t = p * q;
		printf("Scenario #%d:\n", i);
		if (dfs(1, 0, 0)) {
			for (int j = 0; j < t; j++)
				printf("%c%d", way[j][0] + 'A', way[j][1] + 1);
			printf("\n");
		}
		else printf("impossible\n");
		if (i != n)printf("\n");
	}
	return 0;
}
```