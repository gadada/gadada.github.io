---
title: "算法基础part3"
tags:
  - C/C++
  - dp
categories:
  - Algorithm Basics
---
days by days

## 动态规划(Dynamic programming)
通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法，大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。

### Q1
[拦截导弹](http://cxsjsxmooc.openjudge.cn/2020t2springall/012/)

某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。
- 输入：
    输入有两行，
    第一行，输入雷达捕捉到的敌国导弹的数量k（k<=25），
    第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。
- 输出：
    输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。
- 样例输入
    ```markdown
    8
    300 207 155 300 299 170 158 65
    ```
- 样例输出
    ```markdown
    6
    ```

题意即求最长不上升子序列，分解成子问题，依次计算前n个数的最长降序子列，记录为`maxlen[n]`，
```c
#include <stdio.h>
#define maxn(a,b) a > b ? a: b

int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	int n, dp[25], maxlen[25], max = 0;
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) {
		scanf("%d", &dp[i]);
		maxlen[i] = 1;
	}
	for(int i = 1; i < n; ++i)
		for (int j = 0; j < i; ++j) {
			if (dp[i] <= dp[j])
				maxlen[i] = maxn(maxlen[i], maxlen[j] + 1);
		}
	for (int i = 0; i < n; ++i)
		if (max < maxlen[i])max = maxlen[i];
	printf("%d\n", max);

	return 0;
}
```
官方答案基本一致

### Q2
[Zipper](http://cxsjsxmooc.openjudge.cn/2020t2springall/013/)

Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.

For example, consider forming "tcraete" from "cat" and "tree":
```markdown
String A: cat
String B: tree
String C: tcraete
```
As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming "catrtee" from "cat" and "tree":
```markdown
String A: cat
String B: tree
String C: catrtee
```
Finally, notice that it is impossible to form "cttaree" from "cat" and "tree".
- 输入：
    The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.

    For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.
- 输出：
    For each data set, print:`Data set n: yes`

    if the third string can be formed from the first two, or `Data set n: no` if it cannot.

    Of course n should be replaced by the data set number. See the sample output below for an example.
- 样例输入
    ```markdown
    3
    cat tree tcraete
    cat tree catrtee
    cat tree cttaree
    ```
- 样例输出
    ```markdown
    Data set 1: yes
    Data set 2: yes
    Data set 3: no
    ```

判断两个字符串能否顺序拼成一个长的字符串，当第三个字符串的字符等于由前两个字符串任意一个时，即`a[i] = b[j] = c[i+j]`，就要寻找最优解
```c
#include <stdio.h>

int n;
char a[201], b[201], c[401];
int dp(int i, int j)
{
	if (c[i + j] == '\0')return 1;
	if (a[i] != c[i + j] && b[j] != c[i + j])
		return 0;
	if (a[i] == c[i + j] && b[j] != c[i + j])
		return dp(i + 1, j);
	if (a[i] != c[i + j] && b[j] == c[i + j])
		return dp(i, j + 1);
	if (a[i] == c[i + j] && b[j] == c[i + j])
		return dp(i, j + 1) | dp(i + 1, j);
}
int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	scanf("%d", &n);
	int cnt = 0;
	for (int i = 0; i < n; ++i) {
		scanf("%s %s %s", a, b, c);
		++cnt;
		int p = dp(0, 0);
		if (p)printf("Data set %d: yes\n", cnt);
		else printf("Data set %d: no\n", cnt);
	}

	return 0;
}
```
竟然不可以运行，为什么呢？

因为递归过程大量重复计算，200字符就要算到地球毁灭了……所以，必须开一个中间数组，记录计算过的数
```c
#include <stdio.h>
#include <string.h>
int n, dp[201][201];
char a[201], b[201], c[401];
int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	scanf("%d", &n);
	for(int k = 1; k <= n; ++k)
	{
		scanf("%s %s %s", a, b, c);
		memset(dp, 0, sizeof(dp));
		dp[0][0] = 1;
		int l = strlen(a);
		int m = strlen(b);
		for (int i = 0; i <= l; ++i) {
			for (int j = 0; j <= m; ++j) {
				if (dp[i][j] && i < l && a[i] == c[i + j])
					dp[i + 1][j] = 1;
				if (dp[i][j] && j < m && b[j] == c[i + j])
					dp[i][j + 1] = 1;
			}
		}
		if (dp[l][m])
			printf("Data set %d: yes\n", k);
		else
			printf("Data set %d: no\n", k);
	}
	return 0;
}
```
竟然可以运行，为什么呢？

在i，j不越界，且当前数组划分成功的情况下，即`dp[i][j]`

`dp[i][j]`判断当前位置`a[i]`==`c[i+j]`，如果相等则`dp[i + 1][j] = 1`

同时，也需要判断当前位置`b[j]`==`c[i+j]`，如果相等则`dp[i][j + 1] = 1`
