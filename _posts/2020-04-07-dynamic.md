---
title: "算法基础part3"
tags:
  - C/C++
  - dp
categories:
  - Algorithm Basics
---
days by days

## 动态规划(Dynamic programming)
通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法，大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。

### Q1
[拦截导弹](http://cxsjsxmooc.openjudge.cn/2020t2springall/012/)

某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。
- 输入：
    输入有两行，
    第一行，输入雷达捕捉到的敌国导弹的数量k（k<=25），
    第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。
- 输出：
    输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。
- 样例输入
    ```markdown
    8
    300 207 155 300 299 170 158 65
    ```
- 样例输出
    ```markdown
    6
    ```

题意即求最长不上升子序列，分解成子问题，依次计算前n个数的最长降序子列，记录为`maxlen[n]`，
```c
#include <stdio.h>
#define maxn(a,b) a > b ? a: b

int main()
{
	//freopen("E:\\IDMdowanload\\in.txt", "r", stdin);
	int n, dp[25], maxlen[25], max = 0;
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) {
		scanf("%d", &dp[i]);
		maxlen[i] = 1;
	}
	for(int i = 1; i < n; ++i)
		for (int j = 0; j < i; ++j) {
			if (dp[i] <= dp[j])
				maxlen[i] = maxn(maxlen[i], maxlen[j] + 1);
		}
	for (int i = 0; i < n; ++i)
		if (max < maxlen[i])max = maxlen[i];
	printf("%d\n", max);

	return 0;
}
```
官方答案基本一致